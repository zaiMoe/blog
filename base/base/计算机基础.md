# 计算机基础

## 进程、线程、协程、线程

操作系统的主要目标是执行用户程序，但也需要顾及内核之外的各种系统任务。

系统由一组进程组成： 操作系统进程执行系统代码，用户进程执行用户代码。

- 挂起
- I/O 模型： 阻塞、非阻塞、同步、异步

### 进程

> 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

进程的概念主要有两点：

- 进程是一个实体，每一个进程都有自己的地址空间。
- 进程是一个"执行中的程序"，存在嵌套关系。

可看做是正在执行的程序，进程需要一定的资源（如 CPU、时间、内存、文件和 I/O 设备）来完成其任务。 这些资源在创建进程或者执行进程时被分配。

- 进程的组成有：PCB、程序段、数据段
  - PCB（进程控制块，process control block）： 保存进程运行期间相关的数据，是进程存在的唯一标志。
  - 程序段： 能被进程调度程序调度到 CPU 运行的程序的代码段。
  - 数据段： 存储程序运行期间的相关数据，可以是原始数据也可以是相关结果。

创建进程： 需要为进程划分出一块完整的内存空间，有大量的初始化操作，比如要把内存分段（堆栈、正文区等）。

进程在执行时会改变状态，进程的状态有 5 种：
![](./imgs/%E8%BF%9B%E7%A8%8B.png)

- 创建：进程正在被创建。
- 运行：指令正在被执行。
- 等待：阻塞，进程等待某个事件的发生（如 I/O 完成或收到信号）。
- 就绪：进程等待分配处理器。
- 终止：进程完成执行。

> Tips ：将 CPU 切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为上下文切换（context switch） 。

相关命令：

```bash
# 查看所有进程
ps -ef 
```

![](./imgs/运行的进程.png)

- UID: 用户id，在mac下root用户的uid是0，其他用户是uid是501，可以通过uid来判别用户的级别。
- PID: 进程的id
- PPID: 某个进程的父进程，表示这个进程是由父进程发起的，即存在嵌套关系。

![](./imgs/进程嵌套.png)

1. 首先是操作系统进程OS
2. 其次是启动进程，所有的进程都是由sbin/launchd来启动的，这个其实就是一个桌面进程
3. 我们打开了 webstorm/vscode 的编辑器，就相当于开启了一个webstorm/vscode的进程
4. 在编辑器进程中启动了node应用，所以需要有个node进程
5. 在node进程中利用child_process创建nodejs的子进程

作者：小p
链接：<https://juejin.cn/post/7156805991701413902>
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 线程

- 线程是 CPU 使用的基本单元，由线程 ID、程序计数器、寄存器集合和栈组成。
- 进程由一个或多个线程组成： Linux 中创建一个进程自然会创建一个线程，也就是主线程。
- 调度切换： 线程上下文切换比进程上下文切换快。
- 进程创建很耗时间和资源：
  - 创建进程： 需要为进程划分出一块完整的内存空间，有大量的初始化操作，比如要把内存分段（堆栈、正文区等）。
  - 创建线程： 只需要确定 PC 指针和寄存器的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用堆栈。

![](./imgs/线程.png)

有两种不同方法来提供线程支持：

- 用户层的用户线程 ：适合于 IO 密集型任务，受内核支持，而无须内核管理。
- 内核层的内核线程 ：计算密集型任务，由操作系统直接支持和管理。

用户线程与内核线程之间对应关系有三种： 多对一模型、一对一模型、多对多模型

![](./imgs/线程对应关系.png)

- 多对一模型缺点： 任一时刻只有一个线程能访问内核，多个线程不能并行运行在多处理器上。
- 一对一模型缺点： 每创建一个用户线程就需要创建相应的内核线程。限制了系统所支持的线程数量。
- 多对多模型： 没有以上两者的缺点。开发人员可创建任意多的用户线程，并且相应内核线程在多处理器系统上并发执行。

### 协程

> 本质上是轻量级的线程。因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。

![](./imgs/协程.png)

特点：

- 非阻塞 ：具有挂起和恢复的能力。当前协程进行阻塞操作
- 可看作轻量级线程： 占用更少的堆栈空间，并且需要的堆栈大小可以随着程序的运行需要动态增加或者空间回收。
- 上下文切换发生在用户态： 切换速度比较快，并且开销比较小。
