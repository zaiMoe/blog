# 前端的权限设计

在做开发时，遇到过一些权限相关的开发，也开发过权限相关的模块，趁着最近的做开发，进行一次总结

## 术语描述

- 用户：操作的账号，为权限的载体
- 资源：将页面（路由）、页面内容、数据等可以进行权限控制的都称为资源，实际还包括后台接口、服务等。
- 角色：通常是指具有某些共同特征的一组人，比如财务、运维、研发等角色；角色和权限（资源）绑定，通过不同的角色关联不同的权限

## 常见的权限模型

- ACL（Access Control List）：访问控制列表，直接将权限与用户绑定，当用户数量很多的时候，操作一次权限就需要对每个用户都进行授权，工作量很大。
- RBAC（Role-Based Access List）: 基于角色的权限控制，通过 `用户 -> 角色 -> 权限` 的方式，增加了一层角色来间接的赋予用户权限，从而让用户与权限解耦。
- ABAC（Attribute-Based Access Control）: 基于属性的访问控制，通过定义一系列属性（用户属性、环境属性、资源属性），通过动态计算来确定用户是否有权限访问。对于资源的管控力度更细，比如运营(角色)在北京(环境)能查询北京订单(资源)。这种在前端并不常见，有兴趣自行了解。

## 前端的权限控制

前端对权限控制粒度的不同，可以分为：

- 页面权限：包括登录权限、路由、菜单这类，本质上就是在路由层面进行控制
- 页面内容权限：比如没有编辑权限，则隐藏掉相关的UI组件，通常和后台接口挂钩

### 角色固定/较少的方案

![](./imgs/role/role0.png)

这种应该是目前比较常见的一种，角色以及对应的权限由后台维护，前端通常会维护一份路由与角色的 map 配置，例如：

```typescript
const routeConfigs = [
    {
        path: '/path1',
        meta: {
            title: 'path1',
            roles: ['role1', 'role2', 'role3'] // 该条路由那些角色可以访问
        }
    },
     {
        path: '/path2',
        meta: {
            title: 'path2',
            roles: ['role1', 'role2']
        }
    },
    {
        path: '/path3',
        meta: {
            title: 'path3',
            roles: ['role3']
        }
    }
]
```

在页面登录之后，获取到当前用户的角色，然后根据该角色，过滤出有权限的路由和菜单，进行页面初始化。

#### 页面权限

虽然上面在页面上不存在入口让用户点击进入，但如果用户记住某条路由（比如保存到书签），直接用过url进入，那么还是会打开的。所以还需要在路由层面做权限判断，如果没有权限，则跳转403页面。

vue 和 react 的路由拦截都有各自的实现，这里不列出来，只给出主要逻辑伪代码

```typescript
const {enableView} = usePermisesion();

if (!enableView) {
    // 定向到 403 页面
} else {
    // 正常逻辑
}
```

这里的 `usePermisesion` 通过 `routeConfigs` 和 用户角色 来判断是当前路由是否权限进入，用户角色 建议通过全局状态、context之类的注入。

当然这里简化了操作，实际上应该先进行 404 的判断，否则随便输入的 url 都会跳转到 403

#### 内容权限控制

内容权限是比较难处理的，不像页面权限可以通过全局的拦截器进行统一的拦截，需要通过侵入业务代码中。

一些实现方案是将权限需要的角色写到业务中，如：

```jsx
<PermissionControl permisstion={["role1", "role2"]}>
  <Button />
</PermissionControl>

// or
<Button v-permission=["role1", "role2"] />
```

不建议采用这种，一旦要增加一个角色，或者删除一个角色，需要到处找代码。因此统一通过 `usePermisesion` 来获取当前页面的其他权限。只需扩展下 `routeConfigs`：

```typescript
const routeConfigs = [
    {
        path: '/path1',
        meta: {
            title: 'path1',
            permission: { // 对应的操作权限需要的角色
                view: ['role1', 'role2', 'role3'],
                edit: ['role1', 'role2']
            }
        }
    },
     {
        path: '/path2',
        meta: {
            title: 'path2',
            permission: {
                view: ['role1', 'role2'],
                edit: ['role2']
            }
        }
    },
    {
        path: '/path3',
        meta: {
            title: 'path3',
            permission: {
                view: ['role3'],
                edit: ['role3']
            }
        }
    }
]
```

然后封装通用的 权限组件 或者 vue指令，来获取当前页面需要对权限

```tsx
const PermissionControl = ({permissionkey, children}) => {
    const {enableEdit} = usePermisesion();

    if (!enableEdit) {
        return null
    }

    return children
}

// 使用

<PermissionControl><Button /></PermissionControl>
// or
<Button v-permission />
```

##### 特殊权限控制

上面的 `edit` 权限还是针对整个页面级别，如果希望只是页面某个按钮需要更加特殊的权限，比如 【文档发布】 按钮，需要更高的管理权限，依然可以通过上面的 `routeConfigs` 来处理：

```typescript
const routeConfigs = [
    {
        path: '/path1',
        meta: {
            title: 'path1',
            permission: { // 对应的操作权限需要的角色
                view: ['role1', 'role2', 'role3'],
                edit: ['role1', 'role2'],
                xxxButton: ['administrator']
            }
        }
    }
]

const PermissionControl = ({permissionkey, children}) => {
    const {enableEdit} = usePermisesion(permissionkey); // 可以传入 key 来获取指定特定对资源权限

    if (!enableEdit) {
        return null
    }

    return children
}

// 使用

<PermissionControl permissionkey="administrator"><Button /></PermissionControl>
// or
<Button v-permission="administrator" />
```

#### 小结

到这里为止基本上就能够覆盖权限验证在前端需要的几个场景，这种方式适合于小型系统，角色有限的情况。通过 `routeConfigs` 来维护权限与页面资源的映射，也比较清晰简单。但也有明显的不足：

对于大型项目，权限管理往往是复杂的，比如一个系统有几十个不同类别的应用，用户量都比较大，不能简单的抽象成几个简单的角色来控制

对于上面两个局限，往往会采用角色动态创建的方案，通过自定义不同类型的角色，来

### 角色不定的方案

这种方案其实

## 参考

- [前后端分离架构设计（权限模型）](https://zhuanlan.zhihu.com/p/107054677)
